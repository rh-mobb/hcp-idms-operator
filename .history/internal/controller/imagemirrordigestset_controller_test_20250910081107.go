package controller

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	configv1alpha1 "github.com/openshift/hcp-idms-operator/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestVerifyFileOwnership(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registry.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageMirrorDigestSetReconciler{}

	tests := []struct {
		name          string
		fileContent   string
		expectError   bool
		errorContains string
	}{
		{
			name:        "non-existent file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "empty file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "file with correct header should pass",
			fileContent: "# Generated by hcp-idms-operator\n# Some other content",
			expectError: false,
		},
		{
			name:          "file with wrong header should fail",
			fileContent:   "# Generated by some-other-operator\n# Some other content",
			expectError:   true,
			errorContains: "not owned by hcp-idms-operator",
		},
		{
			name:          "file with no header should fail",
			fileContent:   "some content without header",
			expectError:   true,
			errorContains: "not owned by hcp-idms-operator",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			configFile := filepath.Join(registryDir, "test.conf")

			// Create file with content if specified
			if tt.fileContent != "" {
				err := os.WriteFile(configFile, []byte(tt.fileContent), 0644)
				if err != nil {
					t.Fatalf("Failed to create test file: %v", err)
				}
			}

			err := reconciler.verifyFileOwnership(configFile)

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error to contain %q, but got: %v", tt.errorContains, err)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error but got: %v", err)
				}
			}

			// Clean up
			os.Remove(configFile)
		})
	}
}

func TestGenerateRegistryConfigContent(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}

	instance := &configv1alpha1.ImageMirrorDigestSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-mirror",
		},
		Spec: configv1alpha1.ImageMirrorDigestSetSpec{
			Mirrors: []configv1alpha1.RegistryMirror{
				{
					Source:                "quay.io",
					Mirrors:               []string{"mirror.example.com/quay"},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Check that the content starts with the expected header
	if !strings.Contains(content, "# Generated by hcp-idms-operator") {
		t.Errorf("Generated content should start with expected header")
	}

	// Check that it contains the source information
	if !strings.Contains(content, "Source: ImageMirrorDigestSet test-mirror") {
		t.Errorf("Generated content should contain source information")
	}

	// Check that it contains the mirror configuration
	if !strings.Contains(content, "quay.io") {
		t.Errorf("Generated content should contain source registry")
	}

	if !strings.Contains(content, "mirror.example.com/quay") {
		t.Errorf("Generated content should contain mirror URL")
	}
}

func TestShouldIgnoreResource(t *testing.T) {
	tests := []struct {
		name     string
		instance *configv1alpha1.ImageMirrorDigestSet
		expected bool
	}{
		{
			name: "default resource should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "default",
				},
			},
			expected: true,
		},
		{
			name: "hypershift managed resource should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/managed": "true",
					},
				},
			},
			expected: true,
		},
		{
			name: "normal resource should not be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "normal-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagemirrordigestset",
					},
				},
			},
			expected: false,
		},
		{
			name: "resource with other hypershift labels should not be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "other-hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/other": "value",
					},
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test the logic that would be used in the controller
			shouldIgnore := false

			// Check for default name
			if tt.instance.Name == "default" {
				shouldIgnore = true
			}

			// Check for hypershift managed label
			if tt.instance.Labels != nil && tt.instance.Labels["hypershift.openshift.io/managed"] == "true" {
				shouldIgnore = true
			}

			if shouldIgnore != tt.expected {
				t.Errorf("Expected shouldIgnore to be %v, but got %v", tt.expected, shouldIgnore)
			}
		})
	}
}

// TestSampleResourcesToConfigFiles tests that sample resources are properly converted to config files
func TestSampleResourcesToConfigFiles(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}

	// Test cases based on the sample resources
	testCases := []struct {
		name            string
		instance        *configv1alpha1.ImageMirrorDigestSet
		shouldProcess   bool
		expectedFile    string
		expectedContent []string
	}{
		{
			name: "quay-mirror should be processed",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "quay-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagemirrordigestset",
					},
				},
				Spec: configv1alpha1.ImageMirrorDigestSetSpec{
					Mirrors: []configv1alpha1.RegistryMirror{
						{
							Source: "quay.io",
							Mirrors: []string{
								"mirror-registry.example.com/quay",
								"backup-mirror.example.com/quay",
							},
							InsecureSkipTLSVerify: false,
						},
						{
							Source: "registry.redhat.io",
							Mirrors: []string{
								"mirror-registry.example.com/redhat",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: true,
			expectedFile:  "quay-mirror.conf",
			expectedContent: []string{
				"# Generated by hcp-idms-operator",
				"# Source: ImageMirrorDigestSet quay-mirror",
				"[[registry]]",
				"  location = \"docker.io\"",
				"  [[registry.mirror]]",
				"    location = \"quay.io\"",
				"    [[registry.mirror.mirror]]",
				"      location = \"mirror-registry.example.com/quay\"",
				"    [[registry.mirror.mirror]]",
				"      location = \"backup-mirror.example.com/quay\"",
				"  [[registry.mirror]]",
				"    location = \"registry.redhat.io\"",
				"    [[registry.mirror.mirror]]",
				"      location = \"mirror-registry.example.com/redhat\"",
			},
		},
		{
			name: "docker-mirror should be processed",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "docker-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagemirrordigestset",
					},
				},
				Spec: configv1alpha1.ImageMirrorDigestSetSpec{
					Mirrors: []configv1alpha1.RegistryMirror{
						{
							Source: "docker.io",
							Mirrors: []string{
								"mirror-registry.example.com/docker",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: true,
			expectedFile:  "docker-mirror.conf",
			expectedContent: []string{
				"# Generated by hcp-idms-operator",
				"# Source: ImageMirrorDigestSet docker-mirror",
				"[[registry]]",
				"  location = \"docker.io\"",
				"  [[registry.mirror]]",
				"    location = \"docker.io\"",
				"    [[registry.mirror.mirror]]",
				"      location = \"mirror-registry.example.com/docker\"",
			},
		},
		{
			name: "default should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "default",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagemirrordigestset",
					},
				},
				Spec: configv1alpha1.ImageMirrorDigestSetSpec{
					Mirrors: []configv1alpha1.RegistryMirror{
						{
							Source: "docker.io",
							Mirrors: []string{
								"default-mirror.example.com/docker",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: false,
			expectedFile:  "default.conf",
		},
		{
			name: "hypershift-managed should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "hypershift-managed-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/managed": "true",
						"app.kubernetes.io/name":          "imagemirrordigestset",
					},
				},
				Spec: configv1alpha1.ImageMirrorDigestSetSpec{
					Mirrors: []configv1alpha1.RegistryMirror{
						{
							Source: "registry.redhat.io",
							Mirrors: []string{
								"hypershift-mirror.example.com/redhat",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: false,
			expectedFile:  "hypershift-managed-mirror.conf",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Test the filtering logic
			shouldIgnore := false
			if tc.instance.Name == "default" {
				shouldIgnore = true
			}
			if tc.instance.Labels != nil && tc.instance.Labels["hypershift.openshift.io/managed"] == "true" {
				shouldIgnore = true
			}

			if shouldIgnore != !tc.shouldProcess {
				t.Errorf("Expected shouldIgnore to be %v, but got %v", !tc.shouldProcess, shouldIgnore)
			}

			// If the resource should be processed, test the config generation
			if tc.shouldProcess {
				content := reconciler.generateRegistryConfigContent(tc.instance)

				// Verify the generated content
				for _, expected := range tc.expectedContent {
					if !strings.Contains(content, expected) {
						t.Errorf("Expected content to contain %q, but got:\n%s", expected, content)
					}
				}

				// Verify the file would be named correctly
				expectedFileName := tc.expectedFile
				if !strings.Contains(expectedFileName, tc.instance.Name) {
					t.Errorf("Expected filename to contain resource name %q, but got %q", tc.instance.Name, expectedFileName)
				}
			}
		})
	}
}

// TestConfigFileGeneration tests the complete config file generation process
func TestConfigFileGeneration(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registry.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageMirrorDigestSetReconciler{}

	// Test with a complex mirror configuration
	instance := &configv1alpha1.ImageMirrorDigestSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-complex-mirror",
		},
		Spec: configv1alpha1.ImageMirrorDigestSetSpec{
			Mirrors: []configv1alpha1.RegistryMirror{
				{
					Source: "quay.io",
					Mirrors: []string{
						"mirror1.example.com/quay",
						"mirror2.example.com/quay",
					},
					InsecureSkipTLSVerify: false,
				},
				{
					Source: "registry.redhat.io",
					Mirrors: []string{
						"mirror.example.com/redhat",
					},
					InsecureSkipTLSVerify: true,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Verify the structure is valid TOML
	lines := strings.Split(content, "\n")

	// Check for required sections
	hasRegistry := false
	hasMirror := false
	hasInsecure := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "[[registry]]" {
			hasRegistry = true
		}
		if strings.HasPrefix(line, "[[registry.mirror]]") {
			hasMirror = true
		}
		if line == "insecure = true" {
			hasInsecure = true
		}
	}

	if !hasRegistry {
		t.Error("Generated content should contain [[registry]] section")
	}
	if !hasMirror {
		t.Error("Generated content should contain [[registry.mirror]] sections")
	}
	if !hasInsecure {
		t.Error("Generated content should contain insecure = true for the second mirror")
	}

	// Verify specific content
	expectedElements := []string{
		"# Generated by hcp-idms-operator",
		"# Source: ImageMirrorDigestSet test-complex-mirror",
		"location = \"docker.io\"",
		"location = \"quay.io\"",
		"location = \"mirror1.example.com/quay\"",
		"location = \"mirror2.example.com/quay\"",
		"location = \"registry.redhat.io\"",
		"location = \"mirror.example.com/redhat\"",
		"insecure = true",
	}

	for _, expected := range expectedElements {
		if !strings.Contains(content, expected) {
			t.Errorf("Expected content to contain %q, but got:\n%s", expected, content)
		}
	}
}

// TestConfigFileValidation tests that generated config files have proper structure
func TestConfigFileValidation(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}

	instance := &configv1alpha1.ImageMirrorDigestSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "validation-test",
		},
		Spec: configv1alpha1.ImageMirrorDigestSetSpec{
			Mirrors: []configv1alpha1.RegistryMirror{
				{
					Source: "quay.io",
					Mirrors: []string{
						"mirror.example.com/quay",
					},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Verify the content has proper structure
	lines := strings.Split(content, "\n")

	// Should have header comments
	if !strings.Contains(lines[0], "# Generated by hcp-idms-operator") {
		t.Error("First line should be the header comment")
	}

	// Should have source information
	if !strings.Contains(content, "# Source: ImageMirrorDigestSet validation-test") {
		t.Error("Should contain source information")
	}

	// Should have timestamp
	if !strings.Contains(content, "# Generated at:") {
		t.Error("Should contain generation timestamp")
	}

	// Should have proper TOML structure
	hasRegistry := false
	hasLocation := false
	hasMirror := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "[[registry]]" {
			hasRegistry = true
		}
		if strings.HasPrefix(line, "location = \"") {
			hasLocation = true
		}
		if strings.HasPrefix(line, "[[registry.mirror]]") {
			hasMirror = true
		}
	}

	if !hasRegistry {
		t.Error("Should contain [[registry]] section")
	}
	if !hasLocation {
		t.Error("Should contain location definitions")
	}
	if !hasMirror {
		t.Error("Should contain [[registry.mirror]] sections")
	}
}

// TestSampleResourceProcessing tests the complete flow from sample resources to config files
func TestSampleResourceProcessing(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}

	// Test all sample resources
	sampleResources := []*configv1alpha1.ImageMirrorDigestSet{
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "quay-mirror",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagemirrordigestset",
				},
			},
			Spec: configv1alpha1.ImageMirrorDigestSetSpec{
				Mirrors: []configv1alpha1.RegistryMirror{
					{
						Source: "quay.io",
						Mirrors: []string{
							"mirror-registry.example.com/quay",
							"backup-mirror.example.com/quay",
						},
						InsecureSkipTLSVerify: false,
					},
					{
						Source: "registry.redhat.io",
						Mirrors: []string{
							"mirror-registry.example.com/redhat",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "docker-mirror",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagemirrordigestset",
				},
			},
			Spec: configv1alpha1.ImageMirrorDigestSetSpec{
				Mirrors: []configv1alpha1.RegistryMirror{
					{
						Source: "docker.io",
						Mirrors: []string{
							"mirror-registry.example.com/docker",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "default",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagemirrordigestset",
				},
			},
			Spec: configv1alpha1.ImageMirrorDigestSetSpec{
				Mirrors: []configv1alpha1.RegistryMirror{
					{
						Source: "docker.io",
						Mirrors: []string{
							"default-mirror.example.com/docker",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "hypershift-managed-mirror",
				Labels: map[string]string{
					"hypershift.openshift.io/managed": "true",
					"app.kubernetes.io/name":          "imagemirrordigestset",
				},
			},
			Spec: configv1alpha1.ImageMirrorDigestSetSpec{
				Mirrors: []configv1alpha1.RegistryMirror{
					{
						Source: "registry.redhat.io",
						Mirrors: []string{
							"hypershift-mirror.example.com/redhat",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
	}

	processedCount := 0
	ignoredCount := 0

	for _, resource := range sampleResources {
		// Check if resource should be ignored
		shouldIgnore := false
		if resource.Name == "default" {
			shouldIgnore = true
		}
		if resource.Labels != nil && resource.Labels["hypershift.openshift.io/managed"] == "true" {
			shouldIgnore = true
		}

		if shouldIgnore {
			ignoredCount++
			t.Logf("Resource %s should be ignored", resource.Name)
		} else {
			processedCount++
			// Generate config content
			content := reconciler.generateRegistryConfigContent(resource)

			// Verify basic structure
			if !strings.Contains(content, "# Generated by hcp-idms-operator") {
				t.Errorf("Resource %s: Generated content should start with expected header", resource.Name)
			}

			if !strings.Contains(content, "[[registry]]") {
				t.Errorf("Resource %s: Generated content should contain [[registry]] section", resource.Name)
			}

			// Verify it contains the source registry information
			for _, mirror := range resource.Spec.Mirrors {
				if !strings.Contains(content, mirror.Source) {
					t.Errorf("Resource %s: Generated content should contain source registry %s", resource.Name, mirror.Source)
				}

				for _, mirrorURL := range mirror.Mirrors {
					if !strings.Contains(content, mirrorURL) {
						t.Errorf("Resource %s: Generated content should contain mirror URL %s", resource.Name, mirrorURL)
					}
				}
			}

			t.Logf("Resource %s processed successfully", resource.Name)
		}
	}

	// Verify we processed the expected number of resources
	expectedProcessed := 2 // quay-mirror and docker-mirror
	expectedIgnored := 2   // default and hypershift-managed-mirror

	if processedCount != expectedProcessed {
		t.Errorf("Expected %d resources to be processed, but got %d", expectedProcessed, processedCount)
	}

	if ignoredCount != expectedIgnored {
		t.Errorf("Expected %d resources to be ignored, but got %d", expectedIgnored, ignoredCount)
	}
}
