package controller

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	configv1alpha1 "github.com/openshift/hcp-idms-operator/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestVerifyFileOwnership(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registry.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageMirrorDigestSetReconciler{}

	tests := []struct {
		name           string
		fileContent    string
		expectError    bool
		errorContains  string
	}{
		{
			name:        "non-existent file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "empty file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "file with correct header should pass",
			fileContent: "# Generated by hcp-idms-operator\n# Some other content",
			expectError: false,
		},
		{
			name:        "file with wrong header should fail",
			fileContent: "# Generated by some-other-operator\n# Some other content",
			expectError: true,
			errorContains: "not owned by hcp-idms-operator",
		},
		{
			name:        "file with no header should fail",
			fileContent: "some content without header",
			expectError: true,
			errorContains: "not owned by hcp-idms-operator",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			configFile := filepath.Join(registryDir, "test.conf")
			
			// Create file with content if specified
			if tt.fileContent != "" {
				err := os.WriteFile(configFile, []byte(tt.fileContent), 0644)
				if err != nil {
					t.Fatalf("Failed to create test file: %v", err)
				}
			}

			err := reconciler.verifyFileOwnership(configFile)
			
			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error to contain %q, but got: %v", tt.errorContains, err)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error but got: %v", err)
				}
			}

			// Clean up
			os.Remove(configFile)
		})
	}
}

func TestGenerateRegistryConfigContent(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}
	
	instance := &configv1alpha1.ImageMirrorDigestSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-mirror",
		},
		Spec: configv1alpha1.ImageMirrorDigestSetSpec{
			Mirrors: []configv1alpha1.RegistryMirror{
				{
					Source: "quay.io",
					Mirrors: []string{"mirror.example.com/quay"},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)
	
	// Check that the content starts with the expected header
	if !contains(content, "# Generated by hcp-idms-operator") {
		t.Errorf("Generated content should start with expected header")
	}
	
	// Check that it contains the source information
	if !contains(content, "Source: ImageMirrorDigestSet test-mirror") {
		t.Errorf("Generated content should contain source information")
	}
	
	// Check that it contains the mirror configuration
	if !contains(content, "quay.io") {
		t.Errorf("Generated content should contain source registry")
	}
	
	if !contains(content, "mirror.example.com/quay") {
		t.Errorf("Generated content should contain mirror URL")
	}
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && containsSubstring(s, substr)
}

func containsSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
