package controller

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	configv1alpha1 "github.com/openshift/hcp-idms-operator/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestVerifyFileOwnership(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registry.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageMirrorDigestSetReconciler{}

	tests := []struct {
		name           string
		fileContent    string
		expectError    bool
		errorContains  string
	}{
		{
			name:        "non-existent file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "empty file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "file with correct header should pass",
			fileContent: "# Generated by hcp-idms-operator\n# Some other content",
			expectError: false,
		},
		{
			name:        "file with wrong header should fail",
			fileContent: "# Generated by some-other-operator\n# Some other content",
			expectError: true,
			errorContains: "not owned by hcp-idms-operator",
		},
		{
			name:        "file with no header should fail",
			fileContent: "some content without header",
			expectError: true,
			errorContains: "not owned by hcp-idms-operator",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			configFile := filepath.Join(registryDir, "test.conf")
			
			// Create file with content if specified
			if tt.fileContent != "" {
				err := os.WriteFile(configFile, []byte(tt.fileContent), 0644)
				if err != nil {
					t.Fatalf("Failed to create test file: %v", err)
				}
			}

			err := reconciler.verifyFileOwnership(configFile)
			
			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error to contain %q, but got: %v", tt.errorContains, err)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error but got: %v", err)
				}
			}

			// Clean up
			os.Remove(configFile)
		})
	}
}

func TestGenerateRegistryConfigContent(t *testing.T) {
	reconciler := &ImageMirrorDigestSetReconciler{}
	
	instance := &configv1alpha1.ImageMirrorDigestSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-mirror",
		},
		Spec: configv1alpha1.ImageMirrorDigestSetSpec{
			Mirrors: []configv1alpha1.RegistryMirror{
				{
					Source: "quay.io",
					Mirrors: []string{"mirror.example.com/quay"},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)
	
	// Check that the content starts with the expected header
	if !strings.Contains(content, "# Generated by hcp-idms-operator") {
		t.Errorf("Generated content should start with expected header")
	}
	
	// Check that it contains the source information
	if !strings.Contains(content, "Source: ImageMirrorDigestSet test-mirror") {
		t.Errorf("Generated content should contain source information")
	}
	
	// Check that it contains the mirror configuration
	if !strings.Contains(content, "quay.io") {
		t.Errorf("Generated content should contain source registry")
	}
	
	if !strings.Contains(content, "mirror.example.com/quay") {
		t.Errorf("Generated content should contain mirror URL")
	}
}

func TestShouldIgnoreResource(t *testing.T) {
	tests := []struct {
		name     string
		instance *configv1alpha1.ImageMirrorDigestSet
		expected bool
	}{
		{
			name: "default resource should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "default",
				},
			},
			expected: true,
		},
		{
			name: "hypershift managed resource should be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/managed": "true",
					},
				},
			},
			expected: true,
		},
		{
			name: "normal resource should not be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "normal-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagemirrordigestset",
					},
				},
			},
			expected: false,
		},
		{
			name: "resource with other hypershift labels should not be ignored",
			instance: &configv1alpha1.ImageMirrorDigestSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "other-hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/other": "value",
					},
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test the logic that would be used in the controller
			shouldIgnore := false
			
			// Check for default name
			if tt.instance.Name == "default" {
				shouldIgnore = true
			}
			
			// Check for hypershift managed label
			if tt.instance.Labels != nil && tt.instance.Labels["hypershift.openshift.io/managed"] == "true" {
				shouldIgnore = true
			}
			
			if shouldIgnore != tt.expected {
				t.Errorf("Expected shouldIgnore to be %v, but got %v", tt.expected, shouldIgnore)
			}
		})
	}
}