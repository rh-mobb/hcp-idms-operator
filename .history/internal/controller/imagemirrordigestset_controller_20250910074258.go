package controller

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	configv1alpha1 "github.com/openshift/hcp-idms-operator/api/v1alpha1"
)

// ImageMirrorDigestSetReconciler reconciles a ImageMirrorDigestSet object
type ImageMirrorDigestSetReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=config.openshift.io,resources=imagemirrordigestsets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=config.openshift.io,resources=imagemirrordigestsets/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=config.openshift.io,resources=imagemirrordigestsets/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *ImageMirrorDigestSetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// Fetch the ImageMirrorDigestSet instance
	instance := &configv1alpha1.ImageMirrorDigestSet{}
	err := r.Get(ctx, req.NamespacedName, instance)
	if err != nil {
		if errors.IsNotFound(err) {
			// Object not found, return.  Created objects are automatically garbage collected.
			// For additional cleanup logic use finalizers.
			return ctrl.Result{}, nil
		}
		// Error reading the object - requeue the request.
		log.Error(err, "Failed to get ImageMirrorDigestSet")
		return ctrl.Result{}, err
	}

	// Check if this is the "default" resource and ignore it
	if instance.Name == "default" {
		log.Info("Ignoring default ImageMirrorDigestSet resource")
		return ctrl.Result{}, nil
	}

	// Generate registry configuration file
	err = r.generateRegistryConfig(instance)
	if err != nil {
		log.Error(err, "Failed to generate registry configuration")
		return ctrl.Result{}, err
	}

	log.Info("Successfully processed ImageMirrorDigestSet", "name", instance.Name)
	return ctrl.Result{}, nil
}

// generateRegistryConfig creates a registry configuration file for the given ImageMirrorDigestSet
func (r *ImageMirrorDigestSetReconciler) generateRegistryConfig(instance *configv1alpha1.ImageMirrorDigestSet) error {
	// Create the registry.conf.d directory if it doesn't exist
	registryDir := "/etc/containers/registry.conf.d"
	if err := os.MkdirAll(registryDir, 0755); err != nil {
		return fmt.Errorf("failed to create registry directory: %w", err)
	}

	// Check if file already exists and verify ownership
	configFile := filepath.Join(registryDir, fmt.Sprintf("%s.conf", instance.Name))
	if err := r.verifyFileOwnership(configFile); err != nil {
		return fmt.Errorf("file ownership verification failed: %w", err)
	}

	// Generate the configuration file content
	configContent := r.generateRegistryConfigContent(instance)

	// Write the configuration file
	if err := os.WriteFile(configFile, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to write registry configuration file: %w", err)
	}

	// Signal that CRI-O needs to be reloaded
	if err := r.signalCRIOReload(); err != nil {
		return fmt.Errorf("failed to signal CRI-O reload: %w", err)
	}

	return nil
}

// verifyFileOwnership checks if a file exists and if it's owned by this operator
func (r *ImageMirrorDigestSetReconciler) verifyFileOwnership(filePath string) error {
	// If file doesn't exist, it's safe to create
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		return nil
	}

	// Read the first line of the existing file
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open existing file: %w", err)
	}
	defer file.Close()

	// Read the first line
	scanner := bufio.NewScanner(file)
	if !scanner.Scan() {
		// File is empty, safe to overwrite
		return nil
	}

	firstLine := scanner.Text()
	expectedHeader := "# Generated by hcp-idms-operator"

	// Check if the first line matches our expected header
	if firstLine != expectedHeader {
		return fmt.Errorf("file %s is not owned by hcp-idms-operator (first line: %q, expected: %q)", filePath, firstLine, expectedHeader)
	}

	return nil
}

// reloadCRIO reloads the CRI-O service to pick up new registry configuration
func (r *ImageMirrorDigestSetReconciler) reloadCRIO() error {
	// Try to reload CRI-O using systemctl
	cmd := exec.Command("systemctl", "reload", "crio")
	output, err := cmd.CombinedOutput()
	if err != nil {
		// If systemctl fails, try alternative methods
		if err := r.tryAlternativeCRIOReload(); err != nil {
			return fmt.Errorf("failed to reload CRI-O with systemctl (output: %s): %w", string(output), err)
		}
	}
	return nil
}

// tryAlternativeCRIOReload tries alternative methods to reload CRI-O
func (r *ImageMirrorDigestSetReconciler) tryAlternativeCRIOReload() error {
	// Try sending SIGHUP to CRI-O process
	cmd := exec.Command("pkill", "-HUP", "crio")
	if err := cmd.Run(); err != nil {
		// If pkill fails, try restarting the service
		cmd := exec.Command("systemctl", "restart", "crio")
		output, err := cmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("failed to restart CRI-O (output: %s): %w", string(output), err)
		}
	}
	return nil
}

// generateRegistryConfigContent generates the TOML content for the registry configuration
func (r *ImageMirrorDigestSetReconciler) generateRegistryConfigContent(instance *configv1alpha1.ImageMirrorDigestSet) string {
	var content strings.Builder

	content.WriteString("# Generated by hcp-idms-operator\n")
	content.WriteString("# Source: ImageMirrorDigestSet " + instance.Name + "\n")
	content.WriteString("# Generated at: " + time.Now().Format(time.RFC3339) + "\n\n")

	content.WriteString("[[registry]]\n")
	content.WriteString("  location = \"docker.io\"\n")
	content.WriteString("  prefix = \"\"\n\n")

	for _, mirror := range instance.Spec.Mirrors {
		content.WriteString("  [[registry.mirror]]\n")
		content.WriteString(fmt.Sprintf("    location = \"%s\"\n", mirror.Source))

		for _, mirrorURL := range mirror.Mirrors {
			content.WriteString(fmt.Sprintf("    [[registry.mirror.mirror]]\n"))
			content.WriteString(fmt.Sprintf("      location = \"%s\"\n", mirrorURL))
		}

		if mirror.InsecureSkipTLSVerify {
			content.WriteString("    insecure = true\n")
		}
		content.WriteString("\n")
	}

	return content.String()
}

// SetupWithManager sets up the controller with the Manager.
func (r *ImageMirrorDigestSetReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&configv1alpha1.ImageMirrorDigestSet{}).
		Complete(r)
}
