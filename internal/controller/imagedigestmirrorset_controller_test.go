// Copyright 2024 Red Hat, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package controller

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	configv1 "github.com/openshift/hcp-idms-operator/api/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestVerifyFileOwnership(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registries.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageDigestMirrorSetReconciler{}

	tests := []struct {
		name          string
		fileContent   string
		expectError   bool
		errorContains string
	}{
		{
			name:        "non-existent file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "empty file should pass",
			fileContent: "",
			expectError: false,
		},
		{
			name:        "file with correct header should pass",
			fileContent: "# Generated by hcp-idms-operator\n# Some other content",
			expectError: false,
		},
		{
			name:          "file with wrong header should fail",
			fileContent:   "# Generated by some-other-operator\n# Some other content",
			expectError:   true,
			errorContains: "not owned by hcp-idms-operator",
		},
		{
			name:          "file with no header should fail",
			fileContent:   "some content without header",
			expectError:   true,
			errorContains: "not owned by hcp-idms-operator",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			configFile := filepath.Join(registryDir, "test.conf")

			// Create file with content if specified
			if tt.fileContent != "" {
				err := os.WriteFile(configFile, []byte(tt.fileContent), 0644)
				if err != nil {
					t.Fatalf("Failed to create test file: %v", err)
				}
			}

			err := reconciler.verifyFileOwnership(configFile)

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("Expected error to contain %q, but got: %v", tt.errorContains, err)
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error but got: %v", err)
				}
			}

			// Clean up
			os.Remove(configFile)
		})
	}
}

func TestGenerateRegistryConfigContent(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	instance := &configv1.ImageDigestMirrorSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-mirror",
		},
		Spec: configv1.ImageDigestMirrorSetSpec{
			ImageDigestMirrors: []configv1.ImageDigestMirror{
				{
					Source:                "quay.io",
					Mirrors:               []string{"mirror.example.com/quay"},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Check that the content starts with the expected header
	if !strings.Contains(content, "# Generated by hcp-idms-operator") {
		t.Errorf("Generated content should start with expected header")
	}

	// Check that it contains the source information
	if !strings.Contains(content, "Source: ImageDigestMirrorSet test-mirror") {
		t.Errorf("Generated content should contain source information")
	}

	// Check that it contains the mirror configuration
	if !strings.Contains(content, "quay.io") {
		t.Errorf("Generated content should contain source registry")
	}

	if !strings.Contains(content, "mirror.example.com/quay") {
		t.Errorf("Generated content should contain mirror URL")
	}
}

func TestShouldIgnoreResource(t *testing.T) {
	tests := []struct {
		name     string
		instance *configv1.ImageDigestMirrorSet
		expected bool
	}{
		{
			name: "default resource should be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "default",
				},
			},
			expected: true,
		},
		{
			name: "hypershift managed resource should be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/managed": "true",
					},
				},
			},
			expected: true,
		},
		{
			name: "normal resource should not be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "normal-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
			},
			expected: false,
		},
		{
			name: "resource with other hypershift labels should not be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "other-hypershift-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/other": "value",
					},
				},
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test the logic that would be used in the controller
			shouldIgnore := false

			// Check for default name
			if tt.instance.Name == "default" {
				shouldIgnore = true
			}

			// Check for hypershift managed label
			if tt.instance.Labels != nil && tt.instance.Labels["hypershift.openshift.io/managed"] == "true" {
				shouldIgnore = true
			}

			if shouldIgnore != tt.expected {
				t.Errorf("Expected shouldIgnore to be %v, but got %v", tt.expected, shouldIgnore)
			}
		})
	}
}

// TestSampleResourcesToConfigFiles tests that sample resources are properly converted to config files
func TestSampleResourcesToConfigFiles(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test cases based on the sample resources
	testCases := []struct {
		name            string
		instance        *configv1.ImageDigestMirrorSet
		shouldProcess   bool
		expectedFile    string
		expectedContent []string
	}{
		{
			name: "quay-mirror should be processed",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "quay-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "quay.io",
							Mirrors: []string{
								"mirror-registry.example.com/quay",
								"backup-mirror.example.com/quay",
							},
							InsecureSkipTLSVerify: false,
						},
						{
							Source: "registry.redhat.io",
							Mirrors: []string{
								"mirror-registry.example.com/redhat",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: true,
			expectedFile:  "quay-mirror.conf",
			expectedContent: []string{
				"# Generated by hcp-idms-operator",
				"# Source: ImageDigestMirrorSet quay-mirror",
				"[[registry]]",
				"  location = \"quay.io\"",
				"  [[registry.mirror]]",
				"    location = \"mirror-registry.example.com/quay\"",
				"  [[registry.mirror]]",
				"    location = \"backup-mirror.example.com/quay\"",
				"[[registry]]",
				"  location = \"registry.redhat.io\"",
				"  [[registry.mirror]]",
				"    location = \"mirror-registry.example.com/redhat\"",
			},
		},
		{
			name: "docker-mirror should be processed",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "docker-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "docker.io",
							Mirrors: []string{
								"mirror-registry.example.com/docker",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: true,
			expectedFile:  "docker-mirror.conf",
			expectedContent: []string{
				"# Generated by hcp-idms-operator",
				"# Source: ImageDigestMirrorSet docker-mirror",
				"[[registry]]",
				"  location = \"docker.io\"",
				"  [[registry.mirror]]",
				"    location = \"mirror-registry.example.com/docker\"",
			},
		},
		{
			name: "default should be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "default",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "docker.io",
							Mirrors: []string{
								"default-mirror.example.com/docker",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: false,
			expectedFile:  "default.conf",
		},
		{
			name: "hypershift-managed should be ignored",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "hypershift-managed-mirror",
					Labels: map[string]string{
						"hypershift.openshift.io/managed": "true",
						"app.kubernetes.io/name":          "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "registry.redhat.io",
							Mirrors: []string{
								"hypershift-mirror.example.com/redhat",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
			shouldProcess: false,
			expectedFile:  "hypershift-managed-mirror.conf",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Test the filtering logic
			shouldIgnore := false
			if tc.instance.Name == "default" {
				shouldIgnore = true
			}
			if tc.instance.Labels != nil && tc.instance.Labels["hypershift.openshift.io/managed"] == "true" {
				shouldIgnore = true
			}

			if shouldIgnore != !tc.shouldProcess {
				t.Errorf("Expected shouldIgnore to be %v, but got %v", !tc.shouldProcess, shouldIgnore)
			}

			// If the resource should be processed, test the config generation
			if tc.shouldProcess {
				content := reconciler.generateRegistryConfigContent(tc.instance)

				// Verify the generated content
				for _, expected := range tc.expectedContent {
					if !strings.Contains(content, expected) {
						t.Errorf("Expected content to contain %q, but got:\n%s", expected, content)
					}
				}

				// Verify the file would be named correctly
				expectedFileName := tc.expectedFile
				if !strings.Contains(expectedFileName, tc.instance.Name) {
					t.Errorf("Expected filename to contain resource name %q, but got %q", tc.instance.Name, expectedFileName)
				}
			}
		})
	}
}

// TestConfigFileGeneration tests the complete config file generation process
func TestConfigFileGeneration(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registries.conf.d")
	os.MkdirAll(registryDir, 0755)

	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test with a complex mirror configuration
	instance := &configv1.ImageDigestMirrorSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-complex-mirror",
		},
		Spec: configv1.ImageDigestMirrorSetSpec{
			ImageDigestMirrors: []configv1.ImageDigestMirror{
				{
					Source: "quay.io",
					Mirrors: []string{
						"mirror1.example.com/quay",
						"mirror2.example.com/quay",
					},
					InsecureSkipTLSVerify: false,
				},
				{
					Source: "registry.redhat.io",
					Mirrors: []string{
						"mirror.example.com/redhat",
					},
					InsecureSkipTLSVerify: true,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Verify the structure is valid TOML
	lines := strings.Split(content, "\n")

	// Check for required sections
	hasRegistry := false
	hasMirror := false
	hasInsecure := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "[[registry]]" {
			hasRegistry = true
		}
		if strings.HasPrefix(line, "[[registry.mirror]]") {
			hasMirror = true
		}
		if line == "insecure = true" {
			hasInsecure = true
		}
	}

	if !hasRegistry {
		t.Error("Generated content should contain [[registry]] section")
	}
	if !hasMirror {
		t.Error("Generated content should contain [[registry.mirror]] sections")
	}
	if !hasInsecure {
		t.Error("Generated content should contain insecure = true for the second mirror")
	}

	// Verify specific content
	expectedElements := []string{
		"# Generated by hcp-idms-operator",
		"# Source: ImageDigestMirrorSet test-complex-mirror",
		"location = \"quay.io\"",
		"location = \"mirror1.example.com/quay\"",
		"location = \"mirror2.example.com/quay\"",
		"location = \"registry.redhat.io\"",
		"location = \"mirror.example.com/redhat\"",
		"insecure = true",
	}

	for _, expected := range expectedElements {
		if !strings.Contains(content, expected) {
			t.Errorf("Expected content to contain %q, but got:\n%s", expected, content)
		}
	}
}

// TestConfigFileValidation tests that generated config files have proper structure
func TestConfigFileValidation(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	instance := &configv1.ImageDigestMirrorSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "validation-test",
		},
		Spec: configv1.ImageDigestMirrorSetSpec{
			ImageDigestMirrors: []configv1.ImageDigestMirror{
				{
					Source: "quay.io",
					Mirrors: []string{
						"mirror.example.com/quay",
					},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	content := reconciler.generateRegistryConfigContent(instance)

	// Verify the content has proper structure
	lines := strings.Split(content, "\n")

	// Should have header comments
	if !strings.Contains(lines[0], "# Generated by hcp-idms-operator") {
		t.Error("First line should be the header comment")
	}

	// Should have source information
	if !strings.Contains(content, "# Source: ImageDigestMirrorSet validation-test") {
		t.Error("Should contain source information")
	}

	// Should have timestamp
	if !strings.Contains(content, "# Generated at:") {
		t.Error("Should contain generation timestamp")
	}

	// Should have proper TOML structure
	hasRegistry := false
	hasLocation := false
	hasMirror := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "[[registry]]" {
			hasRegistry = true
		}
		if strings.HasPrefix(line, "location = \"") {
			hasLocation = true
		}
		if strings.HasPrefix(line, "[[registry.mirror]]") {
			hasMirror = true
		}
	}

	if !hasRegistry {
		t.Error("Should contain [[registry]] section")
	}
	if !hasLocation {
		t.Error("Should contain location definitions")
	}
	if !hasMirror {
		t.Error("Should contain [[registry.mirror]] sections")
	}
}

// TestSampleResourceProcessing tests the complete flow from sample resources to config files
func TestSampleResourceProcessing(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test all sample resources
	sampleResources := []*configv1.ImageDigestMirrorSet{
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "quay-mirror",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagedigestmirrorset",
				},
			},
			Spec: configv1.ImageDigestMirrorSetSpec{
				ImageDigestMirrors: []configv1.ImageDigestMirror{
					{
						Source: "quay.io",
						Mirrors: []string{
							"mirror-registry.example.com/quay",
							"backup-mirror.example.com/quay",
						},
						InsecureSkipTLSVerify: false,
					},
					{
						Source: "registry.redhat.io",
						Mirrors: []string{
							"mirror-registry.example.com/redhat",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "docker-mirror",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagedigestmirrorset",
				},
			},
			Spec: configv1.ImageDigestMirrorSetSpec{
				ImageDigestMirrors: []configv1.ImageDigestMirror{
					{
						Source: "docker.io",
						Mirrors: []string{
							"mirror-registry.example.com/docker",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "default",
				Labels: map[string]string{
					"app.kubernetes.io/name": "imagedigestmirrorset",
				},
			},
			Spec: configv1.ImageDigestMirrorSetSpec{
				ImageDigestMirrors: []configv1.ImageDigestMirror{
					{
						Source: "docker.io",
						Mirrors: []string{
							"default-mirror.example.com/docker",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
		{
			ObjectMeta: metav1.ObjectMeta{
				Name: "hypershift-managed-mirror",
				Labels: map[string]string{
					"hypershift.openshift.io/managed": "true",
					"app.kubernetes.io/name":          "imagedigestmirrorset",
				},
			},
			Spec: configv1.ImageDigestMirrorSetSpec{
				ImageDigestMirrors: []configv1.ImageDigestMirror{
					{
						Source: "registry.redhat.io",
						Mirrors: []string{
							"hypershift-mirror.example.com/redhat",
						},
						InsecureSkipTLSVerify: false,
					},
				},
			},
		},
	}

	processedCount := 0
	ignoredCount := 0

	for _, resource := range sampleResources {
		// Check if resource should be ignored
		shouldIgnore := false
		if resource.Name == "default" {
			shouldIgnore = true
		}
		if resource.Labels != nil && resource.Labels["hypershift.openshift.io/managed"] == "true" {
			shouldIgnore = true
		}

		if shouldIgnore {
			ignoredCount++
			t.Logf("Resource %s should be ignored", resource.Name)
		} else {
			processedCount++
			// Generate config content
			content := reconciler.generateRegistryConfigContent(resource)

			// Verify basic structure
			if !strings.Contains(content, "# Generated by hcp-idms-operator") {
				t.Errorf("Resource %s: Generated content should start with expected header", resource.Name)
			}

			if !strings.Contains(content, "[[registry]]") {
				t.Errorf("Resource %s: Generated content should contain [[registry]] section", resource.Name)
			}

			// Verify it contains the source registry information
			for _, mirror := range resource.Spec.ImageDigestMirrors {
				if !strings.Contains(content, mirror.Source) {
					t.Errorf("Resource %s: Generated content should contain source registry %s", resource.Name, mirror.Source)
				}

				for _, mirrorURL := range mirror.Mirrors {
					if !strings.Contains(content, mirrorURL) {
						t.Errorf("Resource %s: Generated content should contain mirror URL %s", resource.Name, mirrorURL)
					}
				}
			}

			t.Logf("Resource %s processed successfully", resource.Name)
			t.Logf("Generated config content for %s:\n%s", resource.Name, content)
		}
	}

	// Verify we processed the expected number of resources
	expectedProcessed := 2 // quay-mirror and docker-mirror
	expectedIgnored := 2   // default and hypershift-managed-mirror

	if processedCount != expectedProcessed {
		t.Errorf("Expected %d resources to be processed, but got %d", expectedProcessed, processedCount)
	}

	if ignoredCount != expectedIgnored {
		t.Errorf("Expected %d resources to be ignored, but got %d", expectedIgnored, ignoredCount)
	}
}

// TestShowSampleConfigs demonstrates the actual config files generated from sample resources
func TestShowSampleConfigs(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test each sample resource individually to show the generated configs
	sampleResources := []struct {
		name     string
		instance *configv1.ImageDigestMirrorSet
	}{
		{
			name: "quay-mirror",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "quay-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "quay.io",
							Mirrors: []string{
								"mirror-registry.example.com/quay",
								"backup-mirror.example.com/quay",
							},
							InsecureSkipTLSVerify: false,
						},
						{
							Source: "registry.redhat.io",
							Mirrors: []string{
								"mirror-registry.example.com/redhat",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
		},
		{
			name: "docker-mirror",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{
					Name: "docker-mirror",
					Labels: map[string]string{
						"app.kubernetes.io/name": "imagedigestmirrorset",
					},
				},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "docker.io",
							Mirrors: []string{
								"mirror-registry.example.com/docker",
							},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
		},
	}

	for _, sample := range sampleResources {
		t.Run(sample.name, func(t *testing.T) {
			content := reconciler.generateRegistryConfigContent(sample.instance)

			t.Logf("=== Generated config for %s ===", sample.name)
			t.Logf("File: %s.conf", sample.name)
			t.Logf("Content:\n%s", content)
			t.Logf("=== End config for %s ===\n", sample.name)
		})
	}
}

// TestPodmanConfigValidation validates generated config files using Podman
func TestPodmanConfigValidation(t *testing.T) {
	// Skip if podman is not available
	if _, err := exec.LookPath("podman"); err != nil {
		t.Skip("podman not available, skipping validation test")
	}

	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test with a sample resource
	instance := &configv1.ImageDigestMirrorSet{
		ObjectMeta: metav1.ObjectMeta{
			Name: "test-validation",
		},
		Spec: configv1.ImageDigestMirrorSetSpec{
			ImageDigestMirrors: []configv1.ImageDigestMirror{
				{
					Source: "quay.io",
					Mirrors: []string{
						"mirror-registry.example.com/quay",
					},
					InsecureSkipTLSVerify: false,
				},
			},
		},
	}

	// Generate config content
	content := reconciler.generateRegistryConfigContent(instance)

	// Create a temporary directory for testing
	tempDir := t.TempDir()
	registryDir := filepath.Join(tempDir, "registries.conf.d")
	os.MkdirAll(registryDir, 0755)

	// Write the config file
	configFile := filepath.Join(registryDir, "test-validation.conf")
	err := os.WriteFile(configFile, []byte(content), 0644)
	if err != nil {
		t.Fatalf("Failed to write config file: %v", err)
	}

	// Test 1: Validate TOML syntax using a simple approach
	t.Run("TOML syntax validation", func(t *testing.T) {
		// Check that the content has proper TOML structure
		lines := strings.Split(content, "\n")

		// Should have registry sections
		registryCount := 0
		mirrorCount := 0

		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "[[registry]]" {
				registryCount++
			}
			if strings.HasPrefix(line, "[[registry.mirror]]") {
				mirrorCount++
			}
		}

		if registryCount == 0 {
			t.Error("Generated content should contain at least one [[registry]] section")
		}

		if mirrorCount == 0 {
			t.Error("Generated content should contain at least one [[registry.mirror]] section")
		}

		t.Logf("Found %d registry sections and %d mirror sections", registryCount, mirrorCount)
	})

	// Test 2: Try to validate with podman (if possible)
	t.Run("Podman validation", func(t *testing.T) {
		// Set the registry config path for podman
		env := os.Environ()
		env = append(env, "REGISTRY_CONFIG_PATH="+registryDir)

		// Try to get podman info with our config
		cmd := exec.Command("podman", "info", "--format", "json")
		cmd.Env = env

		output, err := cmd.CombinedOutput()
		if err != nil {
			// This might fail because the mirror registries don't exist,
			// but we can still check if the config was parsed correctly
			t.Logf("Podman info failed (expected if mirrors don't exist): %v", err)
			t.Logf("Output: %s", string(output))
		} else {
			t.Logf("Podman successfully parsed the config: %s", string(output))
		}
	})

	// Test 3: Validate config file structure
	t.Run("Config file structure validation", func(t *testing.T) {
		// Check that the file exists and is readable
		if _, err := os.Stat(configFile); os.IsNotExist(err) {
			t.Errorf("Config file should exist at %s", configFile)
		}

		// Check file permissions
		info, err := os.Stat(configFile)
		if err != nil {
			t.Errorf("Failed to stat config file: %v", err)
		}

		// Should be readable by owner
		if info.Mode()&0400 == 0 {
			t.Error("Config file should be readable by owner")
		}

		t.Logf("Config file permissions: %s", info.Mode())
	})
}

// TestRegistryConfigValidation validates registry config using multiple approaches
func TestRegistryConfigValidation(t *testing.T) {
	reconciler := &ImageDigestMirrorSetReconciler{}

	// Test cases with different configurations
	testCases := []struct {
		name     string
		instance *configv1.ImageDigestMirrorSet
	}{
		{
			name: "simple-mirror",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{Name: "simple-mirror"},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source:                "docker.io",
							Mirrors:               []string{"mirror.example.com/docker"},
							InsecureSkipTLSVerify: false,
						},
					},
				},
			},
		},
		{
			name: "multiple-mirrors",
			instance: &configv1.ImageDigestMirrorSet{
				ObjectMeta: metav1.ObjectMeta{Name: "multiple-mirrors"},
				Spec: configv1.ImageDigestMirrorSetSpec{
					ImageDigestMirrors: []configv1.ImageDigestMirror{
						{
							Source: "quay.io",
							Mirrors: []string{
								"mirror1.example.com/quay",
								"mirror2.example.com/quay",
							},
							InsecureSkipTLSVerify: false,
						},
						{
							Source:                "registry.redhat.io",
							Mirrors:               []string{"mirror.example.com/redhat"},
							InsecureSkipTLSVerify: true,
						},
					},
				},
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			content := reconciler.generateRegistryConfigContent(tc.instance)

			// Validate basic structure
			if !strings.Contains(content, "# Generated by hcp-idms-operator") {
				t.Error("Should contain header comment")
			}

			if !strings.Contains(content, "[[registry]]") {
				t.Error("Should contain registry sections")
			}

			// Validate that each source registry has its own section
			for _, mirror := range tc.instance.Spec.ImageDigestMirrors {
				expectedRegistry := fmt.Sprintf("location = \"%s\"", mirror.Source)
				if !strings.Contains(content, expectedRegistry) {
					t.Errorf("Should contain registry location: %s", expectedRegistry)
				}

				// Validate that each mirror URL is present
				for _, mirrorURL := range mirror.Mirrors {
					expectedMirror := fmt.Sprintf("location = \"%s\"", mirrorURL)
					if !strings.Contains(content, expectedMirror) {
						t.Errorf("Should contain mirror location: %s", expectedMirror)
					}
				}

				// Validate insecure setting
				if mirror.InsecureSkipTLSVerify {
					if !strings.Contains(content, "insecure = true") {
						t.Error("Should contain insecure = true for this mirror")
					}
				}
			}

			t.Logf("Generated config for %s:\n%s", tc.name, content)
		})
	}
}

func TestReloadCRIO(t *testing.T) {
	// This is a basic test that the function exists and can be called
	// In a real environment, we would need to mock the exec.Command calls
	r := &ImageDigestMirrorSetReconciler{}

	// Test that the function exists and doesn't panic
	// Note: This will fail in test environment since systemctl/pkill won't be available
	err := r.reloadCRIO()

	// We expect an error in test environment since systemctl/pkill aren't available
	if err == nil {
		t.Log("CRI-O reload succeeded (unexpected in test environment)")
	} else {
		t.Logf("CRI-O reload failed as expected in test environment: %v", err)
	}
}
